{"ast":null,"code":"import { recurringDB, expenseDB, walletDB } from './db';\n\n// Process recurring transactions that are due\nexport const processRecurringTransactions = async () => {\n  try {\n    // Get all transactions due today or earlier\n    const dueTransactions = await recurringDB.getDueTransactions();\n    if (dueTransactions.length === 0) {\n      return {\n        processed: 0\n      };\n    }\n    let processedCount = 0;\n\n    // Process each due transaction\n    for (const transaction of dueTransactions) {\n      // Create a new transaction from the recurring template\n      const newTransaction = {\n        id: Date.now() + processedCount,\n        // Ensure unique ID\n        name: transaction.name,\n        amount: transaction.amount,\n        category: transaction.category,\n        tags: [...transaction.tags, 'recurring'],\n        // Add the recurring tag\n        walletId: transaction.walletId,\n        isIncome: transaction.isIncome,\n        notes: transaction.notes || '',\n        date: new Date().toISOString().slice(0, 10) // Today's date\n      };\n\n      // Add the transaction\n      await expenseDB.add(newTransaction);\n\n      // Update wallet balance\n      try {\n        const wallets = await walletDB.getAll();\n        const wallet = wallets.find(w => w.id === newTransaction.walletId);\n        if (wallet) {\n          // For income add to balance, for expense subtract\n          const adjustment = newTransaction.isIncome ? parseFloat(newTransaction.amount) : -parseFloat(newTransaction.amount);\n          wallet.balance = parseFloat(wallet.balance) + adjustment;\n          await walletDB.update(wallet);\n        }\n      } catch (walletError) {\n        console.error('Error updating wallet balance:', walletError);\n      }\n\n      // Calculate next occurrence date based on frequency\n      const nextDate = calculateNextDate(transaction.frequency, new Date());\n\n      // Update the recurring transaction with the new next date\n      await recurringDB.update({\n        ...transaction,\n        nextDate: nextDate\n      });\n      processedCount++;\n    }\n\n    // Return success with count of processed transactions\n    return {\n      processed: processedCount,\n      transactions: dueTransactions\n    };\n  } catch (error) {\n    console.error('Error processing recurring transactions:', error);\n    return {\n      error: error.message\n    };\n  }\n};\n\n// Helper function to calculate the next date based on frequency\nconst calculateNextDate = (frequency, currentDate) => {\n  const date = new Date(currentDate);\n  switch (frequency) {\n    case 'daily':\n      date.setDate(date.getDate() + 1);\n      break;\n    case 'weekly':\n      date.setDate(date.getDate() + 7);\n      break;\n    case 'biweekly':\n      date.setDate(date.getDate() + 14);\n      break;\n    case 'monthly':\n      date.setMonth(date.getMonth() + 1);\n      break;\n    case 'quarterly':\n      date.setMonth(date.getMonth() + 3);\n      break;\n    case 'annually':\n      date.setFullYear(date.getFullYear() + 1);\n      break;\n    default:\n      date.setMonth(date.getMonth() + 1);\n    // Default to monthly\n  }\n  return date.toISOString().slice(0, 10);\n};","map":{"version":3,"names":["recurringDB","expenseDB","walletDB","processRecurringTransactions","dueTransactions","getDueTransactions","length","processed","processedCount","transaction","newTransaction","id","Date","now","name","amount","category","tags","walletId","isIncome","notes","date","toISOString","slice","add","wallets","getAll","wallet","find","w","adjustment","parseFloat","balance","update","walletError","console","error","nextDate","calculateNextDate","frequency","transactions","message","currentDate","setDate","getDate","setMonth","getMonth","setFullYear","getFullYear"],"sources":["/Users/ddm/expense-tracker/src/utils/scheduler.js"],"sourcesContent":["import { recurringDB, expenseDB, walletDB } from './db';\n\n// Process recurring transactions that are due\nexport const processRecurringTransactions = async () => {\n  try {\n    // Get all transactions due today or earlier\n    const dueTransactions = await recurringDB.getDueTransactions();\n    \n    if (dueTransactions.length === 0) {\n      return { processed: 0 };\n    }\n    \n    let processedCount = 0;\n    \n    // Process each due transaction\n    for (const transaction of dueTransactions) {\n      // Create a new transaction from the recurring template\n      const newTransaction = {\n        id: Date.now() + processedCount, // Ensure unique ID\n        name: transaction.name,\n        amount: transaction.amount,\n        category: transaction.category,\n        tags: [...transaction.tags, 'recurring'], // Add the recurring tag\n        walletId: transaction.walletId,\n        isIncome: transaction.isIncome,\n        notes: transaction.notes || '',\n        date: new Date().toISOString().slice(0, 10), // Today's date\n      };\n      \n      // Add the transaction\n      await expenseDB.add(newTransaction);\n      \n      // Update wallet balance\n      try {\n        const wallets = await walletDB.getAll();\n        const wallet = wallets.find(w => w.id === newTransaction.walletId);\n        \n        if (wallet) {\n          // For income add to balance, for expense subtract\n          const adjustment = newTransaction.isIncome ? \n            parseFloat(newTransaction.amount) : \n            -parseFloat(newTransaction.amount);\n            \n          wallet.balance = parseFloat(wallet.balance) + adjustment;\n          await walletDB.update(wallet);\n        }\n      } catch (walletError) {\n        console.error('Error updating wallet balance:', walletError);\n      }\n      \n      // Calculate next occurrence date based on frequency\n      const nextDate = calculateNextDate(transaction.frequency, new Date());\n      \n      // Update the recurring transaction with the new next date\n      await recurringDB.update({\n        ...transaction,\n        nextDate: nextDate\n      });\n      \n      processedCount++;\n    }\n    \n    // Return success with count of processed transactions\n    return { \n      processed: processedCount,\n      transactions: dueTransactions \n    };\n  } catch (error) {\n    console.error('Error processing recurring transactions:', error);\n    return { error: error.message };\n  }\n};\n\n// Helper function to calculate the next date based on frequency\nconst calculateNextDate = (frequency, currentDate) => {\n  const date = new Date(currentDate);\n  \n  switch (frequency) {\n    case 'daily':\n      date.setDate(date.getDate() + 1);\n      break;\n    case 'weekly':\n      date.setDate(date.getDate() + 7);\n      break;\n    case 'biweekly':\n      date.setDate(date.getDate() + 14);\n      break;\n    case 'monthly':\n      date.setMonth(date.getMonth() + 1);\n      break;\n    case 'quarterly':\n      date.setMonth(date.getMonth() + 3);\n      break;\n    case 'annually':\n      date.setFullYear(date.getFullYear() + 1);\n      break;\n    default:\n      date.setMonth(date.getMonth() + 1); // Default to monthly\n  }\n  \n  return date.toISOString().slice(0, 10);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}