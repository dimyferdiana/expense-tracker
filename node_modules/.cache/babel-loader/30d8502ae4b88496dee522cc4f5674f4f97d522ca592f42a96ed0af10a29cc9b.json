{"ast":null,"code":"import _objectSpread from\"/Users/ddm/expense-tracker/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{recurringDB,expenseDB,walletDB}from'./db';// Process recurring transactions that are due\nexport const processRecurringTransactions=async()=>{try{// Get all transactions due today or earlier\nconst dueTransactions=await recurringDB.getDueTransactions();if(dueTransactions.length===0){return{processed:0};}let processedCount=0;// Process each due transaction\nfor(const transaction of dueTransactions){// Create a new transaction from the recurring template\nconst newTransaction={id:Date.now()+processedCount,// Ensure unique ID\nname:transaction.name,amount:transaction.amount,category:transaction.category,tags:[...transaction.tags,'recurring'],// Add the recurring tag\nwalletId:transaction.walletId,isIncome:transaction.isIncome,notes:transaction.notes||'',date:new Date().toISOString().slice(0,10)// Today's date\n};// Add the transaction\nawait expenseDB.add(newTransaction);// Update wallet balance\ntry{const wallets=await walletDB.getAll();const wallet=wallets.find(w=>w.id===newTransaction.walletId);if(wallet){// For income add to balance, for expense subtract\nconst adjustment=newTransaction.isIncome?parseFloat(newTransaction.amount):-parseFloat(newTransaction.amount);wallet.balance=parseFloat(wallet.balance)+adjustment;await walletDB.update(wallet);}}catch(walletError){console.error('Error updating wallet balance:',walletError);}// Calculate next occurrence date based on frequency\nconst nextDate=calculateNextDate(transaction.frequency,new Date());// Update the recurring transaction with the new next date\nawait recurringDB.update(_objectSpread(_objectSpread({},transaction),{},{nextDate:nextDate}));processedCount++;}// Return success with count of processed transactions\nreturn{processed:processedCount,transactions:dueTransactions};}catch(error){console.error('Error processing recurring transactions:',error);return{error:error.message};}};// Helper function to calculate the next date based on frequency\nconst calculateNextDate=(frequency,currentDate)=>{const date=new Date(currentDate);switch(frequency){case'daily':date.setDate(date.getDate()+1);break;case'weekly':date.setDate(date.getDate()+7);break;case'biweekly':date.setDate(date.getDate()+14);break;case'monthly':date.setMonth(date.getMonth()+1);break;case'quarterly':date.setMonth(date.getMonth()+3);break;case'annually':date.setFullYear(date.getFullYear()+1);break;default:date.setMonth(date.getMonth()+1);// Default to monthly\n}return date.toISOString().slice(0,10);};","map":{"version":3,"names":["recurringDB","expenseDB","walletDB","processRecurringTransactions","dueTransactions","getDueTransactions","length","processed","processedCount","transaction","newTransaction","id","Date","now","name","amount","category","tags","walletId","isIncome","notes","date","toISOString","slice","add","wallets","getAll","wallet","find","w","adjustment","parseFloat","balance","update","walletError","console","error","nextDate","calculateNextDate","frequency","_objectSpread","transactions","message","currentDate","setDate","getDate","setMonth","getMonth","setFullYear","getFullYear"],"sources":["/Users/ddm/expense-tracker/src/utils/scheduler.js"],"sourcesContent":["import { recurringDB, expenseDB, walletDB } from './db';\n\n// Process recurring transactions that are due\nexport const processRecurringTransactions = async () => {\n  try {\n    // Get all transactions due today or earlier\n    const dueTransactions = await recurringDB.getDueTransactions();\n    \n    if (dueTransactions.length === 0) {\n      return { processed: 0 };\n    }\n    \n    let processedCount = 0;\n    \n    // Process each due transaction\n    for (const transaction of dueTransactions) {\n      // Create a new transaction from the recurring template\n      const newTransaction = {\n        id: Date.now() + processedCount, // Ensure unique ID\n        name: transaction.name,\n        amount: transaction.amount,\n        category: transaction.category,\n        tags: [...transaction.tags, 'recurring'], // Add the recurring tag\n        walletId: transaction.walletId,\n        isIncome: transaction.isIncome,\n        notes: transaction.notes || '',\n        date: new Date().toISOString().slice(0, 10), // Today's date\n      };\n      \n      // Add the transaction\n      await expenseDB.add(newTransaction);\n      \n      // Update wallet balance\n      try {\n        const wallets = await walletDB.getAll();\n        const wallet = wallets.find(w => w.id === newTransaction.walletId);\n        \n        if (wallet) {\n          // For income add to balance, for expense subtract\n          const adjustment = newTransaction.isIncome ? \n            parseFloat(newTransaction.amount) : \n            -parseFloat(newTransaction.amount);\n            \n          wallet.balance = parseFloat(wallet.balance) + adjustment;\n          await walletDB.update(wallet);\n        }\n      } catch (walletError) {\n        console.error('Error updating wallet balance:', walletError);\n      }\n      \n      // Calculate next occurrence date based on frequency\n      const nextDate = calculateNextDate(transaction.frequency, new Date());\n      \n      // Update the recurring transaction with the new next date\n      await recurringDB.update({\n        ...transaction,\n        nextDate: nextDate\n      });\n      \n      processedCount++;\n    }\n    \n    // Return success with count of processed transactions\n    return { \n      processed: processedCount,\n      transactions: dueTransactions \n    };\n  } catch (error) {\n    console.error('Error processing recurring transactions:', error);\n    return { error: error.message };\n  }\n};\n\n// Helper function to calculate the next date based on frequency\nconst calculateNextDate = (frequency, currentDate) => {\n  const date = new Date(currentDate);\n  \n  switch (frequency) {\n    case 'daily':\n      date.setDate(date.getDate() + 1);\n      break;\n    case 'weekly':\n      date.setDate(date.getDate() + 7);\n      break;\n    case 'biweekly':\n      date.setDate(date.getDate() + 14);\n      break;\n    case 'monthly':\n      date.setMonth(date.getMonth() + 1);\n      break;\n    case 'quarterly':\n      date.setMonth(date.getMonth() + 3);\n      break;\n    case 'annually':\n      date.setFullYear(date.getFullYear() + 1);\n      break;\n    default:\n      date.setMonth(date.getMonth() + 1); // Default to monthly\n  }\n  \n  return date.toISOString().slice(0, 10);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}